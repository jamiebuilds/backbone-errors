{"version":3,"sources":["backbone-errors.js"],"names":[],"mappings":"WAAU,IAAI,EAAE,OAAO,EAAE;AACvB;AACE;;AAEA;;AAEA;;mBAEc,QAAQ,EAAE,KAAK,EAAE;AACjC;;AAEA;;;;;;;;;AASA;;;;;;;;;;;;;AAcE,WAAG,UAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE;AAC3B,UAAI,GAAG,CAAC;;AAER,UAAI;AACF,YAAI,OAAO,KAAK,KAAK,CAAC,EAAE;AACtB,aAAG,GAAG,QAAQ,EAAE,CAAC;SAClB,MAAM;AACL,aAAG,GAAG,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SAC9B;OACF,CAAC,OAAO,CAAC,EAAE;AACV,cAAM,SAAM,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;OACvB;;AAED,UACE,GAAG,IAAI,CAAC,OAAO,GAAG,KAAK,QAAQ,IAAI,OAAO,GAAG,KAAK,UAAU,CAAC,IAC7D,OAAO,GAAG,CAAC,IAAI,KAAK,UAAU,EAC9B;AACA,WAAG,SAAM,CAAC,UAAA,CAAC;iBAAI,MAAM,SAAM,CAAC,IAAI,EAAE,CAAC,CAAC;SAAA,CAAC,CAAC;OACvC;;AAED,aAAO,GAAG,CAAC;KACZ;;;;;;;;;;;AAWD,aAAK,YAAG;AACN,aAAO,CAAC,OAAO,MAAA,CAAf,OAAO,EAAY,SAAS,CAAC,CAAC;AAC9B,aAAO,IAAI,CAAC;KACb;;;;;;;;;;;;;AAaD,aAAK,UAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE;AAC7B,aAAO,CAAC,MAAM,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AACxC,aAAO,IAAI,CAAC;KACb;;;;;;;;;;;;;AAaD,aAAS,EAAA,UAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE;AACjC,aAAO,CAAC,UAAU,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AAC5C,aAAO,IAAI,CAAC;KACb;;;;;;;;;;;;;;;;;;;AAmBD,gBAAY,EAAA,UAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE;AACpC,aAAO,CAAC,aAAa,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AAC/C,aAAO,IAAI,CAAC;KACb;;GAEF,CAAC;;AAEF,SAAO,MAAM,CAAC;CACf,CAAC,CAAC","file":"backbone-errors.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['backbone', 'backbone.radio'], factory);\n  } else if (typeof exports !== 'undefined') {\n    module.exports = factory(require('lodash'), require('backbone.radio'));\n  } else {\n    factory(root.Backbone, root.Backbone.Radio);\n  }\n})(this, function(Backbone, Radio) {\n  'use strict';\n\n  let channel = Backbone.Radio.channel('error');\n  \n  /**\n   * Advanced Error Handling for Backbone using Radio. Try, throw, and catch\n   * namespaced errors using Backbone.Radio with built-in promise handling.\n   *\n   * @public\n   * @namespace Errors\n   */\n  let Errors = Backbone.Errors = {\n  \n    /**\n     * Attempt to run a callback, catching any errors thrown and sending them to\n     * their handlers by name. Callback can return a Promise which, if rejected,\n     * will pass it's errors to the handlers as well.\n     *\n     * @public\n     * @method try\n     * @param {String} name - The name of the error handler.\n     * @param {Function} callback - The callback to be executed.\n     * @param {Object} [context] - The context to execute the `callback` with.\n     * @return {*} - The value returned by `callback`.\n     */\n    try(name, callback, context) {\n      let ret;\n  \n      try {\n        if (context === void 0) {\n          ret = callback();\n        } else {\n          ret = callback.call(context);\n        }\n      } catch (e) {\n        Errors.throw(name, e);\n      }\n  \n      if (\n        ret && (typeof ret === 'object' || typeof ret === 'function') &&\n        typeof ret.then === 'function'\n      ) {\n        ret.catch(e => Errors.throw(name, e));\n      }\n  \n      return ret;\n    },\n  \n    /**\n     * Throw an error into its handler by `name`.\n     *\n     * @public\n     * @method throw\n     * @param {String} name - The name of the error handler.\n     * @param {...*} args - Additional arguments to be passed to the handler.\n     * @return {Object} - The `Errors` object, useful for chaining.\n     */\n    throw() {\n      channel.command(...arguments);\n      return this;\n    },\n  \n    /**\n     * Catch an error in a `callback` function by `name`. Passing `\"default\"` will\n     * set the default handler for all errors.\n     *\n     * @public\n     * @method catch\n     * @param {String} name - The name of the error handler.\n     * @param {Function} callback - The callback to be executed.\n     * @param {Object} [context] - The context to execute the `callback` with.\n     * @return {Object} - The `Errors` object, useful for chaining.\n     */\n    catch(name, callback, context) {\n      channel.comply(name, callback, context);\n      return this;\n    },\n  \n    /**\n     * Catch an error only to be thrown a single time. After the first time the\n     * error is caught, it will be removed.\n     *\n     * @public\n     * @method catchOnce\n     * @param {String} name - The name of the error handler.\n     * @param {Function} callback - The callback to be executed.\n     * @param {Object} [context] - The context to execute the `callback` with.\n     * @return {Object} - The `Errors` object, useful for chaining.\n     */\n    catchOnce(name, callback, context) {\n      channel.complyOnce(name, callback, context);\n      return this;\n    },\n  \n    /**\n     * Remove one or many handlers. If `context` is passed, then all handlers with\n     * that context will be removed. If `callback` is passed, then all handlers\n     * with that callback will be removed. If `name` is passed then this method\n     * will remove that handler. If no arguments are passed then all handlers are\n     * removed from the object.\n     *\n     * You may also pass a hash of error handlers or space-separated list to\n     * remove many error handlers at once.\n     *\n     * @public\n     * @method stopCatching\n     * @param {String} [name] - The name of the error handler.\n     * @param {Function} [callback] - The callback to be executed.\n     * @param {Object} [context] - The context to execute the `callback` with.\n     * @return {Object} - The `Errors` object, useful for chaining.\n     */\n    stopCatching(name, callback, context) {\n      channel.stopComplying(name, callback, context);\n      return this;\n    }\n  \n  };\n  \n  return Errors;\n});\n"],"sourceRoot":"/source/"}