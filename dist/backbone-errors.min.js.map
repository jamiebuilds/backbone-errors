{"version":3,"sources":["/source/backbone-errors.js"],"names":[],"mappings":"UAAU,EAAM,GACd,kBAAA,SAAA,OAAA,IACE,QAAA,WAAA,kBAAA,+BAEA,OAAA,QAAA,EAAA,QAAA,UAAA,QAAA,mBAEA,EAAA,EAAA,SAAA,EAAA,SAAA,sBAEc,GAChB,YAEA,IAAA,GAAA,EAAA,MAAA,QAAA,SASA,EAAA,EAAA,QAcE,MAAG,SAAC,EAAM,EAAU,GAClB,GAAI,EAEJ,KAEI,EADc,SAAZ,EACI,IAEA,EAAS,KAAK,GAEtB,MAAO,GACP,EAAM,SAAO,EAAM,GAUrB,OANE,GAAuB,gBAAR,IAAmC,kBAAR,IACtB,kBAAb,GAAI,MAEX,EAAG,SAAO,SAAA,SAAK,GAAM,SAAO,EAAM,KAG7B,GAYT,QAAK,WAEH,MADA,GAAQ,QAAO,MAAf,EAAmB,WACZ,MAcT,QAAK,SAAC,EAAM,EAAU,GAEpB,MADA,GAAQ,OAAO,EAAM,EAAU,GACxB,MAcT,UAAS,SAAC,EAAM,EAAU,GAExB,MADA,GAAQ,WAAW,EAAM,EAAU,GAC5B,MAoBT,aAAY,SAAC,EAAM,EAAU,GAE3B,MADA,GAAQ,cAAc,EAAM,EAAU,GAC/B,MAKX,OAAO","file":"backbone-errors.min.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['backbone', 'backbone.radio'], factory);\n  } else if (typeof exports !== 'undefined') {\n    module.exports = factory(require('lodash'), require('backbone.radio'));\n  } else {\n    factory(root.Backbone, root.Backbone.Radio);\n  }\n})(this, function(Backbone, Radio) {\n  'use strict';\n\n  let channel = Backbone.Radio.channel('error');\n  \n  /**\n   * Advanced Error Handling for Backbone using Radio. Try, throw, and catch\n   * namespaced errors using Backbone.Radio with built-in promise handling.\n   *\n   * @public\n   * @namespace Errors\n   */\n  let Errors = Backbone.Errors = {\n  \n    /**\n     * Attempt to run a callback, catching any errors thrown and sending them to\n     * their handlers by name. Callback can return a Promise which, if rejected,\n     * will pass it's errors to the handlers as well.\n     *\n     * @public\n     * @method try\n     * @param {String} name - The name of the error handler.\n     * @param {Function} callback - The callback to be executed.\n     * @param {Object} [context] - The context to execute the `callback` with.\n     * @return {*} - The value returned by `callback`.\n     */\n    try(name, callback, context) {\n      let ret;\n  \n      try {\n        if (context === void 0) {\n          ret = callback();\n        } else {\n          ret = callback.call(context);\n        }\n      } catch (e) {\n        Errors.throw(name, e);\n      }\n  \n      if (\n        ret && (typeof ret === 'object' || typeof ret === 'function') &&\n        typeof ret.then === 'function'\n      ) {\n        ret.catch(e => Errors.throw(name, e));\n      }\n  \n      return ret;\n    },\n  \n    /**\n     * Throw an error into its handler by `name`.\n     *\n     * @public\n     * @method throw\n     * @param {String} name - The name of the error handler.\n     * @param {...*} args - Additional arguments to be passed to the handler.\n     * @return {Object} - The `Errors` object, useful for chaining.\n     */\n    throw() {\n      channel.command(...arguments);\n      return this;\n    },\n  \n    /**\n     * Catch an error in a `callback` function by `name`. Passing `\"default\"` will\n     * set the default handler for all errors.\n     *\n     * @public\n     * @method catch\n     * @param {String} name - The name of the error handler.\n     * @param {Function} callback - The callback to be executed.\n     * @param {Object} [context] - The context to execute the `callback` with.\n     * @return {Object} - The `Errors` object, useful for chaining.\n     */\n    catch(name, callback, context) {\n      channel.comply(name, callback, context);\n      return this;\n    },\n  \n    /**\n     * Catch an error only to be thrown a single time. After the first time the\n     * error is caught, it will be removed.\n     *\n     * @public\n     * @method catchOnce\n     * @param {String} name - The name of the error handler.\n     * @param {Function} callback - The callback to be executed.\n     * @param {Object} [context] - The context to execute the `callback` with.\n     * @return {Object} - The `Errors` object, useful for chaining.\n     */\n    catchOnce(name, callback, context) {\n      channel.complyOnce(name, callback, context);\n      return this;\n    },\n  \n    /**\n     * Remove one or many handlers. If `context` is passed, then all handlers with\n     * that context will be removed. If `callback` is passed, then all handlers\n     * with that callback will be removed. If `name` is passed then this method\n     * will remove that handler. If no arguments are passed then all handlers are\n     * removed from the object.\n     *\n     * You may also pass a hash of error handlers or space-separated list to\n     * remove many error handlers at once.\n     *\n     * @public\n     * @method stopCatching\n     * @param {String} [name] - The name of the error handler.\n     * @param {Function} [callback] - The callback to be executed.\n     * @param {Object} [context] - The context to execute the `callback` with.\n     * @return {Object} - The `Errors` object, useful for chaining.\n     */\n    stopCatching(name, callback, context) {\n      channel.stopComplying(name, callback, context);\n      return this;\n    }\n  \n  };\n  \n  return Errors;\n});\n"],"sourceRoot":"/source/"}